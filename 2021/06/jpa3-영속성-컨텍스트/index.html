<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.97.3 with theme Tranquilpeak 0.4.8-BETA"><meta name=author content="GyeongSoo Kim"><meta name=keywords content><meta name=description content="영속성 컨텍스트(Persistence Context)는 엔티티를 영구 저정하는 환경을 의미합니다. 좀 더 쉽게 풀어보자면 DB를 통해 얻어온 데이터들을 저장하는 내부 저장소가 있음을 의미합니다. 내부 저장소가 있음으로서 얻는 이점이 있기 때문입니다.
 엔티티: 영속성 컨텍스트에 저장되는 도메인(혹은 데이터) 객체  JPA에서는 영속성 컨텍스트에 접근하기 위해 엔티티 매니저(EntityManager)를 사용하고 있습니다. 엔티티 매니저를 통해 엔티티들의 라이프 사이클을 관리할 수 있게 됩니다. 엔티티의 라이프 사이클을 비영속, 영속, 준영속, 삭제 상태가 있습니다.
  비영속(new/transient): 영속성 컨텍스트와 전혀 관계없는 새로운 상태."><meta property="og:description" content="영속성 컨텍스트(Persistence Context)는 엔티티를 영구 저정하는 환경을 의미합니다. 좀 더 쉽게 풀어보자면 DB를 통해 얻어온 데이터들을 저장하는 내부 저장소가 있음을 의미합니다. 내부 저장소가 있음으로서 얻는 이점이 있기 때문입니다.
 엔티티: 영속성 컨텍스트에 저장되는 도메인(혹은 데이터) 객체  JPA에서는 영속성 컨텍스트에 접근하기 위해 엔티티 매니저(EntityManager)를 사용하고 있습니다. 엔티티 매니저를 통해 엔티티들의 라이프 사이클을 관리할 수 있게 됩니다. 엔티티의 라이프 사이클을 비영속, 영속, 준영속, 삭제 상태가 있습니다.
  비영속(new/transient): 영속성 컨텍스트와 전혀 관계없는 새로운 상태."><meta property="og:type" content="article"><meta property="og:title" content="JPA3 - 영속성 컨텍스트"><meta name=twitter:title content="JPA3 - 영속성 컨텍스트"><meta property="og:url" content="https://wondsn.github.io/2021/06/jpa3-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"><meta property="twitter:url" content="https://wondsn.github.io/2021/06/jpa3-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"><meta property="og:site_name" content="삽질할수록 기억에 더 남는다"><meta property="og:description" content="영속성 컨텍스트(Persistence Context)는 엔티티를 영구 저정하는 환경을 의미합니다. 좀 더 쉽게 풀어보자면 DB를 통해 얻어온 데이터들을 저장하는 내부 저장소가 있음을 의미합니다. 내부 저장소가 있음으로서 얻는 이점이 있기 때문입니다.
 엔티티: 영속성 컨텍스트에 저장되는 도메인(혹은 데이터) 객체  JPA에서는 영속성 컨텍스트에 접근하기 위해 엔티티 매니저(EntityManager)를 사용하고 있습니다. 엔티티 매니저를 통해 엔티티들의 라이프 사이클을 관리할 수 있게 됩니다. 엔티티의 라이프 사이클을 비영속, 영속, 준영속, 삭제 상태가 있습니다.
  비영속(new/transient): 영속성 컨텍스트와 전혀 관계없는 새로운 상태."><meta name=twitter:description content="영속성 컨텍스트(Persistence Context)는 엔티티를 영구 저정하는 환경을 의미합니다. 좀 더 쉽게 풀어보자면 DB를 통해 얻어온 데이터들을 저장하는 내부 저장소가 있음을 의미합니다. 내부 저장소가 있음으로서 얻는 이점이 있기 때문입니다.
 엔티티: 영속성 컨텍스트에 저장되는 도메인(혹은 데이터) 객체  JPA에서는 영속성 컨텍스트에 접근하기 위해 엔티티 매니저(EntityManager)를 사용하고 있습니다. 엔티티 매니저를 통해 엔티티들의 라이프 사이클을 관리할 수 있게 됩니다. 엔티티의 라이프 사이클을 비영속, 영속, 준영속, 삭제 상태가 있습니다.
  비영속(new/transient): 영속성 컨텍스트와 전혀 관계없는 새로운 상태."><meta property="og:locale" content="ko-kr"><meta property="article:published_time" content="2021-06-18T20:05:24"><meta property="article:modified_time" content="2021-06-18T20:05:24"><meta property="article:section" content="spring"><meta property="article:tag" content="jpa"><meta property="article:tag" content="database"><meta name=twitter:card content="summary"><meta property="og:image" content="https://www.gravatar.com/avatar/8a4b021722069de48354b90aff5ae7b9?s=640"><meta property="twitter:image" content="https://www.gravatar.com/avatar/8a4b021722069de48354b90aff5ae7b9?s=640"><title>JPA3 - 영속성 컨텍스트</title><link rel=icon href=https://wondsn.github.io/favicon.png><link rel=canonical href=https://wondsn.github.io/2021/06/jpa3-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin=anonymous><link rel=stylesheet href=https://wondsn.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css></head><body><div id=blog><header id=header data-behavior=2><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://wondsn.github.io/>삽질할수록 기억에 더 남는다</a></div><a class=header-right-picture href=https://wondsn.github.io/about><img class=header-picture src="https://www.gravatar.com/avatar/8a4b021722069de48354b90aff5ae7b9?s=90" alt></a></header><nav id=sidebar data-behavior=2><div class=sidebar-container><div class=sidebar-profile><a href=https://wondsn.github.io/about><img class=sidebar-profile-picture src="https://www.gravatar.com/avatar/8a4b021722069de48354b90aff5ae7b9?s=110" alt></a><h4 class=sidebar-profile-name>GyeongSoo Kim</h4><h5 class=sidebar-profile-bio>I love <em>language learning</em>, <em>development</em>.</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://wondsn.github.io/><i class="sidebar-button-icon fa fa-lg fa-home"></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://wondsn.github.io/categories><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://wondsn.github.io/tags><i class="sidebar-button-icon fa fa-lg fa-tags"></i>
<span class=sidebar-button-desc>Tags</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://wondsn.github.io/archives><i class="sidebar-button-icon fa fa-lg fa-archive"></i>
<span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://wondsn.github.io/about><i class="sidebar-button-icon fa fa-lg fa-question"></i>
<span class=sidebar-button-desc>About</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/kimgs0725 target=_blank rel=noopener><i class="sidebar-button-icon fa fa-lg fa-github"></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=2 class=hasCoverMetaIn><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class="post-header main-content-wrap text-left"><h1 class=post-title itemprop=headline>JPA3 - 영속성 컨텍스트</h1><div class="postShorten-meta post-meta"><time itemprop=datePublished datetime=2021-06-18T20:05:24+09:00>18, 2021</time>
<span></span>
<a class=category-link href=https://wondsn.github.io/categories/spring>spring</a></div></div><div class="post-content markdown" itemprop=articleBody><div class=main-content-wrap><p>영속성 컨텍스트(Persistence Context)는 <strong>엔티티를 영구 저정하는 환경</strong>을 의미합니다. 좀 더 쉽게 풀어보자면 DB를 통해 얻어온 데이터들을 저장하는 내부 저장소가 있음을 의미합니다. 내부 저장소가 있음으로서 얻는 이점이 있기 때문입니다.</p><ul><li>엔티티: 영속성 컨텍스트에 저장되는 도메인(혹은 데이터) 객체</li></ul><p>JPA에서는 영속성 컨텍스트에 접근하기 위해 엔티티 매니저(EntityManager)를 사용하고 있습니다. 엔티티 매니저를 통해 엔티티들의 라이프 사이클을 관리할 수 있게 됩니다. 엔티티의 라이프 사이클을 비영속, 영속, 준영속, 삭제 상태가 있습니다.</p><p><img src=https://wondsn.github.io/images/entity_lifecycle.png alt></p><ul><li><p>비영속(new/transient): 영속성 컨텍스트와 전혀 관계없는 <strong>새로운</strong> 상태. 영속성 컨텍스트가 관리하지 않는 엔티티를 의미합니다.</p><p><img src=https://wondsn.github.io/images/detach_entity.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Member member <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Member<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>member<span style=color:#f92672>.</span><span style=color:#a6e22e>setId</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;member1&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>member<span style=color:#f92672>.</span><span style=color:#a6e22e>setUsername</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;회원1&#34;</span><span style=color:#f92672>);</span>
</span></span></code></pre></div></li><li><p>영속(managed): 영속성 컨텍스트에 <strong>관리</strong>되는 상태. 영속성 컨텍스트에 의해 <strong>엔티티 변경 감지부터 지연 로딩, 동일성을 보장</strong>해줍니다.</p><p><img src=https://wondsn.github.io/images/managed_entity.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Member member <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Member<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>member<span style=color:#f92672>.</span><span style=color:#a6e22e>setId</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;member1&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>member<span style=color:#f92672>.</span><span style=color:#a6e22e>setUsername</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;회원1&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>EntityManager em <span style=color:#f92672>=</span> emf<span style=color:#f92672>.</span><span style=color:#a6e22e>createEntityManager</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>getTransaction</span><span style=color:#f92672>().</span><span style=color:#a6e22e>begin</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 객체를 영속성 컨텍스트안에 저장한 상태(영속)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>member<span style=color:#f92672>);</span>
</span></span></code></pre></div></li><li><p>준영속(detached): 영속성 컨텍스트에 저장되었다가 <strong>분리</strong>된 상태.</p></li><li><p>삭제(removed): <strong>삭제</strong>된 상태. 트랜잭션이 끝나면 DB에 삭제 쿼리가 나가게 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>detach</span><span style=color:#f92672>(</span>member<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 객체를 삭제한 상태(삭제)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span>member<span style=color:#f92672>);</span>
</span></span></code></pre></div></li></ul><p>영속성 컨텍스트를 지원함으로써 애플리케이션이 갖는 이점은 다음과 같습니다.</p><h4 id=내부적으로-1차-캐시를-갖고-있게-됩니다>내부적으로 1차 캐시를 갖고 있게 됩니다.</h4><p>엔티티 매니저를 통해 조회하거나, 생성된 엔티티들 1차 캐시에 저장되게 됩니다. 캐시에 저장된 엔티티들은 고유의 ID를 지니고 있게됩니다. 엔티티를 생성하면 엔티티에 1차 캐시에 저장하게 됩니다. 이후에 해당 엔티티를 조회하게 되면 1차 캐시에 저장된 엔티티를 반환하게 됩니다. 하지만 1차 캐시에 조회하고자 하는 엔티티가 없으면 DB에 select 쿼리를 보내게 됩니다. 그러고 쿼리 결과를 1차 캐시에 저장하고 나서 엔티티를 반환하게 됩니다.</p><p><img src=https://wondsn.github.io/images/entity_cache2.png alt></p><h4 id=엔티티-간의-동일성identity이-보장됩니다>엔티티 간의 동일성(Identity)이 보장됩니다.</h4><p>1차 캐시에 의해 REPEATABLE READ 수준의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션에서 지원해줍니다. 영속성 컨텍스트에 의해 관리되는 엔티티는 조회를 해도 같은 엔티티를 반환하게 됩니다.</p><p>✧ REPEATABLE READ: <a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels>트랜잭션 격리 레벨</a>의 한 종류로서 read operation을 반복해서 수행하더라도 읽어 들이는 값이 변화되지 않는 정보의 isolation을 보장하는 level입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Member entity1 <span style=color:#f92672>=</span> em<span style=color:#f92672>.</span><span style=color:#a6e22e>find</span><span style=color:#f92672>(</span>Member<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;member1&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>Member entity2 <span style=color:#f92672>=</span> em<span style=color:#f92672>.</span><span style=color:#a6e22e>find</span><span style=color:#f92672>(</span>Member<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;member1&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assertThat<span style=color:#f92672>(</span>entity1<span style=color:#f92672>).</span><span style=color:#a6e22e>isEqualTo</span><span style=color:#f92672>(</span>entity2<span style=color:#f92672>);</span>
</span></span></code></pre></div><h4 id=트랜잭션을-지원하는-쓰기-지연transactional-write-behind>트랜잭션을 지원하는 쓰기 지연(transactional write-behind)</h4><p>영속성 컨텍스트에 저장되는 엔티티들은 트랜잭션이 끝나기 전까지 DB에 저장되지 않습니다. 대신 쓰기 지연 저장소에 Insert 쿼리문을 저장하고 있디가 트랜잭션이 종료되면 쓰기 지연 저장소에 저장된 쿼리문을 DB으로 보내게 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>EntityManager em <span style=color:#f92672>=</span> emf<span style=color:#f92672>.</span><span style=color:#a6e22e>createEntityManager</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>EntityTransaction transaction <span style=color:#f92672>=</span> em<span style=color:#f92672>.</span><span style=color:#a6e22e>getTransaction</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>begin</span><span style=color:#f92672>();</span>  <span style=color:#75715e>// 트랜잭션 시장
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>memberA<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>memberB<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 이 때까지 INSERT 쿼리를 보내지 않는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>commit</span><span style=color:#f92672>();</span>   <span style=color:#75715e>// 트랜잭션 커밋. 이 순간에 INSERT 쿼리를 보내게 된다.
</span></span></span></code></pre></div><p><img src=https://wondsn.github.io/images/write_behind1.png alt>
<img src=https://wondsn.github.io/images/write_behind2.png alt></p><p>memberA와 memberB를 저장할 때에는 쓰기 지연 저장소에 INSERT 쿼리를 저장해둡니다. 그리고 동일성 보장을 위해 1차 캐시에도 엔티티를 저장합니다. 그리고 나서 <code>commit</code> 메소드가 호출되면 쓰기 지연 저장소에 저장해둔 INSERT 쿼리문을 DB로 날리게 됩니다.</p><p><img src=https://wondsn.github.io/images/write_behind3.png alt></p><p>이렇게 함으로써 저장할 때마다 빈번한 DB I/O를 수행하지 않아도 됩니다. 쓰기 지연 저장소에서 한꺼번에 저장하게 되지만, 너무 많은 INSERT 쿼리가 하나씩 날라가므로 네트워크 낭비가 심해질 수 있습니다. 이는 <a href=https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#batch-jdbcbatch>JDBC Batching</a> 기능을 이용하여 동일한 엔티티 INSERT 쿼리문을 하나로 묶을 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> A <span style=color:#66d9ef>values</span> a1
</span></span><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> B <span style=color:#66d9ef>values</span> b1
</span></span><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> A <span style=color:#66d9ef>values</span> a2
</span></span><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> B <span style=color:#66d9ef>values</span> b2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> A <span style=color:#66d9ef>values</span> (a1, a2)
</span></span><span style=display:flex><span><span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> B <span style=color:#66d9ef>values</span> (b1, b2)
</span></span></code></pre></div><h4 id=영속성-컨텍스트-내-엔티티가-변경-사항을-감지합니다-dirty-checking>영속성 컨텍스트 내 엔티티가 변경 사항을 감지합니다. (Dirty Checking)</h4><p>1차 캐시에 저장된 엔티티는 저장된 순간의 스냅샷을 미리 남겨놓습니다. 그러고나서 엔티티에 변화가 생기게 되면(일부 필드가 바뀐다든지), 엔티티와 스냅샷과 비교합니다.(Dirty Checking) 그리고 나서 변경된 점에 대해 UPDATE 쿼리를 작성하여 쓰기 지연 저장소에 저장합니다. 그리고 쓰기 지연 저장소에 저장된 쿼리문들과 함께 DB에 쿼리를 날리게 됩니다. 이처럼 1차 캐시에 있음으로써 엔티티의 Dirty Checking이 가능해진다는 점이 또 하나의 장점이 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>EntityManager em <span style=color:#f92672>=</span> emf<span style=color:#f92672>.</span><span style=color:#a6e22e>createEntityManager</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>EntityTransaction transaction <span style=color:#f92672>=</span> em<span style=color:#f92672>.</span><span style=color:#a6e22e>getTransaction</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>begin</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 영속 엔티티 조회
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Member memberA <span style=color:#f92672>=</span> em<span style=color:#f92672>.</span><span style=color:#a6e22e>find</span><span style=color:#f92672>(</span>Member<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;memberA&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 영속 엔티티 데이터 수정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>memberA<span style=color:#f92672>.</span><span style=color:#a6e22e>setUsername</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;hi&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>memberA<span style=color:#f92672>.</span><span style=color:#a6e22e>setAge</span><span style=color:#f92672>(</span>10<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 수정되기 전 memberA의 스냅샷과 수정된 memberA를 비교하여 UPDATE 쿼리문을 작성하게 됨.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>transaction<span style=color:#f92672>.</span><span style=color:#a6e22e>commit</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><p><img src=https://wondsn.github.io/images/dirty_checking.png alt></p><h4 id=지연-로딩을-지원합니다-lazy-loading>지연 로딩을 지원합니다. (Lazy Loading)</h4><p>엔티티는 다른 엔티티와 연관관계를 맺을 수 있습니다.(DB에서 외래키를 갖는다고 하죠!!) 그래서 엔티티를 조회할 때 연관된 다른 엔티티까지 조회하기 위해서 조인 연산을 통해서 얻어오게 됩니다. 하지만 연관관계가 많은 엔티티가 조회된다면 해당 엔티티를 얻기 위해 조인 연산이 많이 일어나게 되고, 이는 성능저하로 이어질 수 있습니다. 이를 위해 JPA에서는 지연 로딩(Lazy Loading)을 지원하고 있습니다. Lazy Loading을 통해 연관된 엔티티가 사용된 시점에 DB에서 SELECT 쿼리를 날려 조회하게 됩니다. 이는 JPA에서 프록시 기능을 지원하기 때문에 가능할 수 있습니다. 프록시에 대해서는 뒤에서 다루도록 하겠습니다.</p><p>위에서 쓰기 지연 저장소에 있는 쿼리문을 DB로 날리는 작업을 한다고 했습니다. 그 작업을 플러시(Flush)라고 합니다. 플러시 작업은 EntityManager의 flush 함수를 직접 호출하거나, 트랜잭션 커밋이 발생하거나, JPQL 쿼리가 실행될 때 수행하게 됩니다. 플러시 모드도 변경할 수 있는데 <code>FlushModeType.AUTO</code>와 <code>FlushModeType.COMMIT</code> 타입이 존재한다. <code>em.setFlushMode</code> 함수를 통해 수정할 수 있으며, <code>FlushModeType.AUTO</code>는 커밋이나 쿼리를 실행할 때 플러시하는 것을 의미하고, <code>FlushModeType.COMMIT</code>은 커밋할 때만 플러시하는 것을 의미합니다. 주로 기본값인 <code>FlushModeType.AUTO</code>로 놓고 사용하게 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>memberA<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>memberB<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>em<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>memberC<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Member<span style=color:#f92672>&gt;</span> members <span style=color:#f92672>=</span> em<span style=color:#f92672>.</span><span style=color:#a6e22e>createQuery</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;select m from Member m&#34;</span><span style=color:#f92672>,</span> Member<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>getResultList</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><p>여기서 왜 JPQL(일단 SQL 쿼리라고 생각하자) 쿼리를 날릴 때에도 플러시가 수행되는지 의아해 할 것입니다. 이는 JPA 시멘틱와도 연관지어서 얘기할 수 있습니다. JPA는 <strong>데이터를 리스트에 저장</strong>하듯 시멘틱이 진행이 됩니다. 하지만 여태 애기한 것을 떠올려 보십시오. memberA, B, C는 전부 쓰기 지연 저장소에 저장하고 있는 반면에, JPQL은 DB로 직접 쿼리를 날리게 됩니다. DB에는 memberA, B, C에 대한 내용이 없을테니 JPQL의 쿼리는 빈 리스트를 반환하게 될 것입니다. 하지만 이는 JPA의 시멘틱에 맞지 않는 결과를 가지게 됩니다.(리스트에 저장했는데, 조회할려니까 조회가 안되네??) 그래서 JPQL 쿼리를 날릴 때에도 쓰기 지연 저장소에 있는 쿼리문을 날리게 된 것입니다.</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small"></span><br><a class="tag tag--primary tag--small" href=https://wondsn.github.io/tags/jpa/>jpa</a>
<a class="tag tag--primary tag--small" href=https://wondsn.github.io/tags/database/>database</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://wondsn.github.io/2021/06/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/ data-tooltip="프록시 패턴"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://wondsn.github.io/2021/02/jpa2-jpa-%EC%86%8C%EA%B0%9C/ data-tooltip="JPA2 - JPA 소개"><span class="hide-xs hide-sm text-small icon-mr"></span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.facebook.com/sharer/sharer.php?u=https://wondsn.github.io/2021/06/jpa3-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"><i class="fa fa-facebook-official"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div><div id=disqus_thread><noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2022 GyeongSoo Kim.</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=2><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://wondsn.github.io/2021/06/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/ data-tooltip="프록시 패턴"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml"></span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://wondsn.github.io/2021/02/jpa2-jpa-%EC%86%8C%EA%B0%9C/ data-tooltip="JPA2 - JPA 소개"><span class="hide-xs hide-sm text-small icon-mr"></span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.facebook.com/sharer/sharer.php?u=https://wondsn.github.io/2021/06/jpa3-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"><i class="fa fa-facebook-official"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#><i class="fa fa-list"></i></a></li></ul></div></div><div id=share-options-bar class=share-options-bar data-behavior=2><i id=btn-close-shareoptions class="fa fa-close"></i><ul class=share-options><li class=share-option><a class=share-option-btn target=new href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwondsn.github.io%2F2021%2F06%2Fjpa3-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EC%25BB%25A8%25ED%2585%258D%25EC%258A%25A4%25ED%258A%25B8%2F"><i class="fa fa-facebook-official"></i><span>%!(EXTRA string=Facebook)</span></a></li></ul></div><div id=share-options-mask class=share-options-mask></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-remove"></i></div><img id=about-card-picture src="https://www.gravatar.com/avatar/8a4b021722069de48354b90aff5ae7b9?s=110" alt><h4 id=about-card-name>GyeongSoo Kim</h4><div id=about-card-bio>I love <em>language learning</em>, <em>development</em>.</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Development</div><div id=about-card-location><i class="fa fa-map-marker"></i><br>Bundang, Korea</div></div></div><div id=cover style=background-image:url(https://wondsn.github.io/images/cover-v1.2.0.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin=anonymous></script>
<script src=https://wondsn.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js></script>
<script lang=javascript>window.onload=updateMinWidth,window.onresize=updateMinWidth,document.getElementById("sidebar").addEventListener("transitionend",updateMinWidth);function updateMinWidth(){var n,s,o,t=document.getElementById("sidebar"),e=document.getElementById("main");e.style.minWidth="",n=getComputedStyle(e).getPropertyValue("min-width"),s=getComputedStyle(t).getPropertyValue("width"),o=getComputedStyle(t).getPropertyValue("left"),e.style.minWidth=`calc(${n} - ${s} - ${o})`}</script><script>$(document).ready(function(){hljs.configure({classPrefix:'',useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(t,e){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(e)})})</script><script>var disqus_config=function(){this.page.url="https://wondsn.github.io/2021/06/jpa3-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/",this.page.identifier="/2021/06/jpa3-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"};(function(){if(window.location.hostname=="localhost")return;var e=document,t=e.createElement("script"),n="hugo-tranquilpeak-theme";t.src="//"+n+".disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script></body></html>