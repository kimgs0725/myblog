<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>디자인패턴 on 삽질할수록 기억에 더 남는다</title><link>https://wondsn.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/</link><description>Recent content in 디자인패턴 on 삽질할수록 기억에 더 남는다</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Jun 2021 22:15:56 +0900</lastBuildDate><atom:link href="https://wondsn.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>프록시 패턴</title><link>https://wondsn.github.io/2021/06/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</link><pubDate>Tue, 22 Jun 2021 22:15:56 +0900</pubDate><guid>https://wondsn.github.io/2021/06/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</guid><description>팀 내에서 디자인 패턴에 대해서 스터디를 진행하고 있어서, 공부한 내용을 정리하는 차원에서 남깁니다.
프록시 패턴은 사용할 객체의 제어권을 위임함으로써, 객체에 대한 클라이언트의 요청을 대신 받아서 전달합니다.
프록시(Proxy)는 대리권을 의미하는 단어로써 프록시 패턴을 객체에 대한 제어권을 위임받는 별도의 객체를 통해 객체에 대한 클라이언트의 요청을 대리하여 수행한다. 그렇다면, 프록시는 구체적으로 어떻게 클라이언트의 요청을 대리하여 수행하고 있을까?
우선 Subject 인터페이스와 그것을 구현하는 RealSubject와 Proxy 구현합니다. 그리고 Proxy가 RealProxy를 참조하고 있게 됩니다. 그리고 나서 클라이언트가 Subject 인터페이스를 통해서 메소드를 호출하면 Proxy 내 메소드가 호출되고, Proxy 메소드 안에서 RealSubject의 메소드를 대신 호출하게 됩니다.</description></item></channel></rss>